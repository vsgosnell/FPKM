---
title: "Analyzing RNA-seq Data with the FPKM Package"
author: "Veronica Gosnell"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{FPKM Demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This vignette demonstrates how to use the `FPKM` package to analyze RNA-seq data. We will cover several common tasks, such as reading in RNA-seq data, filtering low-expression genes, normalizing for gene length and sequencing depth, and generating key visualizations (heatmaps, boxplots, PCA).

## Installation

First, make sure you have the `FPKM` package installed. You can install it from GitHub with the following command:

```{r}
# Install devtools if not installed
# install.packages("devtools")
devtools::install_github("vsgosnell/FPKM")
```

# Loading the Package
## Once installed, load the package:


```{r}
library(FPKM)
```

# Loading Data
The first step in RNA-seq analysis is to load your data. We will load the RNA-seq data from the `vehicle_drug_feature_counts.txt` file. The file contains read counts for multiple samples, including vehicle and drug treatment conditions.


```{r}
# Set the path to your data file
data_path <- "/Users/veronicagosnell/Desktop/R/FPKM/data/vehicle_drug_feature_counts.txt"

# Load the data using the read_rna_seq_data function
# Assuming the data is formatted correctly and the function is available in the FPKM package
vehicle_drug_data <- read_rna_seq_data(data_path)
```

# View the first few rows to confirm it loaded correctly

```{r}
head(vehicle_drug_data)
```

## The dataset contains the following columns:

- Geneid: The gene identifier

- Chr: The chromosome

- Start: The start position of the gene

- End: The end position of the gene

- Strand: The strand of the gene

- Length: The length of the gene

- vehicle_rep1.bam, vehicle_rep2.bam, drug_rep1.bam, drug_rep2.bam: 
- The read counts for different replicates of the vehicle and drug treatments.

# Calculating FPKM Values

Once the data is loaded, you can compute FPKM (Fragments Per Kilobase of transcript per Million mapped reads) values. The calculate_fpkm() function calculates the FPKM values from read counts and gene lengths.

```{r}
# Extract count columns by directly selecting columns with count data
counts <- vehicle_drug_data[, c("vehicle_rep1", "vehicle_rep2", "drug_rep1", "drug_rep2")]

# Check if counts has data and the correct number of rows
str(counts)
dim(counts)

# Extract gene lengths
gene_lengths <- as.numeric(vehicle_drug_data$Length)

# Check gene lengths
length(gene_lengths)

# Ensure counts and gene_lengths have the same number of rows
if (nrow(counts) == length(gene_lengths)) {
  # Calculate FPKM values
  fpkm_values <- calculate_fpkm(counts, gene_lengths)
  head(fpkm_values)
} else {
  # Print an error message if counts and gene_lengths have different lengths
  stop("Error: Mismatch between counts rows and gene_lengths entries.")
}
```
This function returns a data frame containing the FPKM values for each gene across all samples.

# Filtering Low Expression Genes

To improve the accuracy of downstream analysis, we can filter out genes with low expression levels. The filter_low_expression() function allows us to filter genes based on a threshold FPKM value.

```{r}
# Filter out genes with low expression (e.g., FPKM < 1)
filtered_data <- filter_low_expression(fpkm_values, threshold = 1)

# ensure filtered_data is numeric before passing it to plotting functions
filtered_data <- filtered_data[, sapply(filtered_data, is.numeric)]

# View the first few rows of the filtered data
head(filtered_data)
```

# Visualizing Gene Expression

## Heatmap of Gene Expression

We can create a heatmap to visualize the gene expression patterns across the samples using the plot_expression_heatmap() function.


```{r}
# Ensure the data is numeric before passing to pheatmap
numeric_data <- filtered_data[, sapply(filtered_data, is.numeric)]

if (ncol(numeric_data) > 0) {
  
  # Remove rows with NAs
  numeric_data <- numeric_data[complete.cases(numeric_data), ]
  
  # Remove columns and rows that are entirely zero
  numeric_data <- numeric_data[, colSums(numeric_data != 0) > 0]
  numeric_data <- numeric_data[rowSums(numeric_data != 0) > 0, ]
  
  # Convert to a proper numeric matrix
  numeric_matrix <- as.matrix(numeric_data)
  
  # Check structure of the matrix
  print("Checking structure of numeric_matrix before scaling:")
  print(str(numeric_matrix))
  
  # Ensure row names are preserved before scaling
  rownames(numeric_matrix) <- rownames(filtered_data)[complete.cases(filtered_data)]
  colnames(numeric_matrix) <- colnames(filtered_data)[sapply(filtered_data, is.numeric)]
  
  # Impute NAs with the column means
  numeric_matrix[is.na(numeric_matrix)] <- colMeans(numeric_matrix, na.rm = TRUE)
  
  # Check if matrix has any non-numeric values after imputation
  print("Is numeric_matrix numeric?")
  print(is.numeric(numeric_matrix))
  
  # Check if there are any NA or NaN values
  print("Any NA values in numeric_matrix?")
  print(any(is.na(numeric_matrix)))
  
  # Check rowMeans
  row_means <- rowMeans(numeric_matrix, na.rm = TRUE)
  print("Row Means:")
  print(row_means)
  
  # Test matrix (sweep adjustment if necessary)
  numeric_matrix <- sweep(numeric_matrix, 1, row_means, FUN = "-")
  
  # Scale the matrix
  numeric_matrix <- scale(numeric_matrix)
  
  # Check final structure before passing to pheatmap
  print("Checking final numeric_matrix before heatmap:")
  print(str(numeric_matrix))
  
  # Create the heatmap
  pheatmap::pheatmap(numeric_matrix,
                     scale = "row",
                     clustering_distance_rows = "euclidean",
                     clustering_distance_cols = "euclidean",
                     clustering_method = "complete",
                     color = colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(100))
  
} else {
  stop("Filtered data contains no numeric values.")
}

```


## Boxplot of FPKM Distribution

A boxplot can be helpful to visualize the distribution of gene expression across samples.

```{r}
# Check the structure of filtered_data
str(filtered_data)

# Add a dummy 'Gene' column if missing
if (!"Gene" %in% colnames(filtered_data)) {
  filtered_data$Gene <- paste("Gene", 1:nrow(filtered_data), sep = "_")
}

# Set the 'Gene' column as row names and remove it from the data
rownames(filtered_data) <- filtered_data$Gene
filtered_data$Gene <- NULL

# Extract numeric data (just the sample columns)
numeric_data <- filtered_data[, sapply(filtered_data, is.numeric)]

# Log-transform the data
log_fpkm <- log2(numeric_data + 1)

# Reshape the data into long format using melt from reshape2 package
log_fpkm$Gene <- rownames(log_fpkm)  # Add Gene column for reshaping
long_fpkm <- reshape2::melt(log_fpkm, id.vars = "Gene")
colnames(long_fpkm) <- c("Gene", "Sample", "logFPKM")

# Check the reshaped data
print("Head of reshaped data:")
head(long_fpkm)

# Plot boxplot of FPKM values
ggplot(long_fpkm, aes(x = Sample, y = logFPKM)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "FPKM Expression Boxplot", y = "log2(FPKM + 1)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Distribution of FPKM Values

To assess the overall distribution of expression levels, we can plot the distribution of FPKM values.

```{r}
# Convert to data frame if it's still a matrix
filtered_data <- as.data.frame(filtered_data)

# Add a column for average FPKM across all samples
filtered_data$FPKM <- rowMeans(filtered_data[, sapply(filtered_data, is.numeric)])

# Then plot distribution of FPKM values
plot_fpkm_distribution(filtered_data$FPKM)
```


# Principal Component Analysis (PCA)

To explore the overall variation in the data, we can perform Principal Component Analysis (PCA) on the FPKM values.

```{r}
# select numeric columns from filtered_data
numeric_data <- filtered_data[, sapply(filtered_data, is.numeric)]

# Perform PCA on the numeric filtered FPKM values
plot_pca_fpkm(numeric_data)
```

This PCA plot will help us understand how the samples cluster based on their gene expression profiles.


# Correlation Between Samples

We can also check the correlation between samples using the plot_sample_correlation() function.

```{r}
# Plot correlation between samples
plot_sample_correlation(numeric_data)
```

# Conclusion

This vignette demonstrated how to use the FPKM package for RNA-seq data analysis. We loaded a dataset, calculated FPKM values, filtered low expression genes, and visualized the data using heatmaps, boxplots, and PCA. These steps provide a solid foundation for further exploration of gene expression data.

For more information on the FPKM package, please refer to the package documentation or explore additional functions for advanced analysis.

